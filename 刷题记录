
953. Verifying an Alien Dictionary
Easy
Logic: 
	Use a for loop to go through all word in words list, for each word, use an inner for loop to check the order of letters.
	Retrieve the order of the alphabet, we could use a map since retrieve data from a map, the time complexity will be O(1)
Code:
class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        # return self.method1(words, order)
        # return self.method2(words, order)
        return self.method3(words, order)
    
    
    def method1(self, words, order):
        """
        Time: O(N) where N is the number of words
        Space: O(1) we only use 26 characters space to store the order
        """
        d = {}
        for idx, cha in enumerate(order):  # Time: O(26), Space:O(26)
            d[cha] = idx
            
        for pre, cur in zip(words, words[1:]):  # Time: O(N)
            if len(pre) > len(cur) and cur == pre[:len(cur)]:
                return False
            
            for cha_pre, cha_cur in zip(pre, cur):  # Time: O(20)
                if d[cha_pre] > d[cha_cur]:
                    return False
                elif d[cha_pre] < d[cha_cur]:
                    break
            
        return True
    
    
    def method2(self, words, order):
        """
        Time: O(N)
        Space: O(1)
        """
        d = {}
        for idx, cha in enumerate(order):
            d[cha] = idx
            
        for i in range(len(words) - 1):
            for j in range(len(words[i])):
                if j >= len(words[i+1]):
                    return False
                if words[i][j] != words[i+1][j]:
                    if d[words[i][j]] > d[words[i+1][j]]:
                        return False
                    break
        return True

    
    def method3(self, words, order):
        """
        Time: O(N)
        Space: O(1)
        """
        d = {c: i for i, c in enumerate(order)}
        words = [[d[char] for char in word] for word in words]
        return all(w1 <= w2 for w1, w2 in zip(words, words[1:]))


================================================================================================================================================================== Meta


680. Valid Palindrome II
Easy
Logic:
	Use 2 pointer: p1 -> 0, p2 -> len(s)-1
        Compare s[p1] and s[p2], once s[p1] != s[p2]: delete s[p1] or s[p2]
Code:
class Solution:
    def validPalindrome(self, s: str) -> bool:
        return self.method(s)
        
        
    def method(self, s):
        """
        assume N characters in s
        Time: O(N)
        Space: O(1)
        """
        p1, p2 = 0, len(s) - 1
        while p1 < p2:            # O(N*1/2)
            if s[p1] != s[p2]:
                temp1 = s[:p1] + s[p1+1:]
                temp2 = s[:p2] + s[p2+1:]
                return temp1 == temp1[::-1] or temp2 == temp2[::-1]
            p1 += 1
            p2 -= 1
            
        return True


================================================================================================================================================================== Meta


1428. Leftmost Column with at Least a One
Medium
Logic:
	method1:
		retrieve number in the matrix one by one, and return the 1st 1 in this matrix
	method2:
		use binary search to search each row (get by a for loop), store the position of 1, and return the minimum position.
Code:
# """
# This is BinaryMatrix's API interface.
# You should not implement it, or speculate about its implementation
# """
#class BinaryMatrix(object):
#    def get(self, row: int, col: int) -> int:
#    def dimensions(self) -> list[]:

class Solution:
    def leftMostColumnWithOne(self, binaryMatrix: 'BinaryMatrix') -> int:
        # return self.method1(binaryMatrix)
        return self.method2(binaryMatrix)
        
        
    def method1(self, binaryMatrix):
        rows, cols = binaryMatrix.dimensions()  # [rows, cols]
        temp = cols + 1
        
        for r in range(rows):
            for c in range(cols):
                num = binaryMatrix.get(r, c)
                if num == 1:
                    temp = min(temp, c)
                    break
        return -1 if temp > cols else temp
    
    
    def method2(self, binaryMatrix):
        rows, cols = binaryMatrix.dimensions()
        temp = cols + 1
        
        for row in range(rows):
        
            p1, p2 = 0, cols - 1
            while p1 < p2:
                mid = (p1 + p2) // 2
                if binaryMatrix.get(row, mid) == 0:
                    p1 = mid + 1
                else:
                    p2 = mid
                    
            if binaryMatrix.get(row, p1) == 1:
                temp = min(temp, p1)
                
        return -1 if temp > cols else temp


================================================================================================================================================================== Meta


973. K Closest Points to Origin
Medium
Logic:
	Precompute the Euclidean distances of each point. Store the distance and position in a list
	Sort the list by distance
	Retrieve top kth element
	
Code:
class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        return self.method(points, k)
        
    def distance(self, point1, point2=[0, 0]):
        dx = (point1[0] - point2[0]) ** 2
        dy = (point1[1] - point2[1]) ** 2
        return (dx + dy) ** 0.5
    
    def method(self, points, k):
        """
        Time: O(NlogN)
        """
        d, ans = [], []
        for i in range(len(points)):  # O(N)
            temp = self.distance(points[i])
            d.append([temp, i])
        d.sort(key=lambda x: x[0])  # O(NlogN)
        
        for i in d[:k]:  # O(K)
            ans.append(points[i[1]])
        return ans


================================================================================================================================================================== Meta


1570. Dot Product of Two Sparse Vectors
Medium
Logic:
	Go through all elements in two vectors, and if both the numbers in these 2 vectors are not 0, times them and plus the result to the answer
Code:
class SparseVector:
    def __init__(self, nums: List[int]):
        self.array = nums

    # Return the dotProduct of two sparse vectors
    def dotProduct(self, vec: 'SparseVector') -> int:
        return self.method1(vec)
    
    def method1(self, vec):
        res = 0
        for num1, num2 in zip(self.array, vec.array):
            res += num1 * num2
        return res

# Your SparseVector object will be instantiated and called as such:
# v1 = SparseVector(nums1)
# v2 = SparseVector(nums2)
# ans = v1.dotProduct(v2)


================================================================================================================================================================== Meta


938. Range Sum of BST
Easy
Logic:
	method1:
		get all node's values into a array, and search all values in the array one by one, append matched value into answer array
	method2:
		Since this tree is a binary search tree, which means the smaller value would be at the left side and greater value would be at the right side
		So check the current value, if in the range, add the value into answer, otherwise,
		if the current value smaller than the range, go search the right side tree
		if the current value greater than the range, go search the left side tree
Code:
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:
        # return self.method1(root, L, R)
        return self.method2(root, L, R)
        
        
    def method1(self, node, L, R):
        """
        Time: O(N^2)
        Space: O(N)
        """
        ans = 0  # Space: O(1)
        values = []  # Space: O(N)

        def get_values(tree):
            if tree:
                values.append(tree.val)
                get_values(tree.left)
                get_values(tree.right)

        get_values(node)  # Tiem: O(N)

        for n in values:  # Time: O(N)
            if n >= L and n <= R:
                ans += n
        return ans

    def method2(self, node, L, R):
        """
        Time: O(N)
        Space: O(1)
        """
        if node:
            if node.val < L:
                return self.method2(node.right, L, R)
            elif node.val > R:
                return self.method2(node.left, L, R)
            else:
                return node.val + self.method2(node.left, L, R) + self.method2(node.right, L, R)
        return 0
    

================================================================================================================================================================== Meta


1762. Buildings With an Ocean View
Medium
Logic:
	check from the right side, and start from the 2nd building from the right side, mark the highest building,
	if the current building is greater than the highest, add it into the answer and update the highest
Code:
class Solution:
    def findBuildings(self, heights: List[int]) -> List[int]:
        return self.method1(heights)
        
    def method1(self, heights):
        """
        Assume it has N buildings there, and M buildings has ocean view
        Time: O(N)
        Space: O(M)
        """
        ans = []  # Space:O(M)
        max_building = heights[-1]  # Space: O(1)
        ans.append(len(heights) - 1)
        
        if len(heights) > 1:
            for i in range(len(heights)-2, -1, -1):  # Time: O(N-1)
                if heights[i] > max_building:
                    ans.append(i)
                    max_building = heights[i]
                    
        return ans[::-1] 


================================================================================================================================================================== Meta


0000. HeadLine
Difficulty
Logic:
	Logic
Code:
Code    


================================================================================================================================================================== Meta


0000. HeadLine
Difficulty
Logic:
	Logic
Code:
Code    


================================================================================================================================================================== Meta


0000. HeadLine
Difficulty
Logic:
	Logic
Code:
Code    


================================================================================================================================================================== Meta


0000. HeadLine
Difficulty
Logic:
	Logic
Code:
Code    


================================================================================================================================================================== Meta


0000. HeadLine
Difficulty
Logic:
	Logic
Code:
Code    


================================================================================================================================================================== Meta


0000. HeadLine
Difficulty
Logic:
	Logic
Code:
Code    


================================================================================================================================================================== Meta


0000. HeadLine
Difficulty
Logic:
	Logic
Code:
Code    


================================================================================================================================================================== Meta


0000. HeadLine
Difficulty
Logic:
	Logic
Code:
Code